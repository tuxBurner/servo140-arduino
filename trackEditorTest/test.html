<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body>
    <button onclick="addPart('straight');">Std Gerade</button>
    <button onclick="addPart('dblStraight');">Doppel Gerade</button>
    <button onclick="addPart('thirdStraight');">Drittel Gerade</button>
    <button onclick="addPart('fourthStraight');">Viertel Gerade</button>
    <button onclick="addPart('curve90');">Kurve 90°</button>
    <button onclick="addPart('curve45');">Kurve 45°</button>
    <button href="#" onclick="exportData()">Export</button>
    <hr />
    <button href="#" onclick="rotatePart(false)">Rotate Left</button>
    <button href="#" onclick="rotatePart(true)">Rotate Right</button>
    <button href="#" onclick="deletePart()">Delete</button>

    <div id="container"></div>
    <script src="kinetic-v5.1.0.min.js"></script>
    <script defer="defer">
      
       // sequence for the part ids
       var partIdSeq = 0;
      
      // ratio for calc is 4.62962963 * cm 
      // avaible partTypes
      var partTypes = {
        straight : {
          width: 100,
          height: 66.66,
          connections: [
            {x: 0,
            y: 33.33,
            acceptedRotation: 0
            },{
              x: 100,
              y: 33.33,
            acceptedRotation: 0
            }
          ]  
        },
        dblStraight : {
          width: 200,
          height: 66.66,
          connections: [
            {x: 0,
            y: 33.33,
            acceptedRotation: 0
            },{
              x: 200,
              y: 33.33,
            acceptedRotation: 0
            }
          ]  
        },
        thirdStraight : {
          width: 33.33,
          height: 66.66,
          connections: [
            {x: 0,
            y: 33.33,
            acceptedRotation: 0
            },{
              x: 33.33,
              y: 33.33,
            acceptedRotation: 0
            }
          ]  
        },
        fourthStraight : {
          width: 25,
          height: 66.66,
          connections: [
            {x: 0,
            y: 33.33,
            acceptedRotation: 0
            },{
              x: 25,
              y: 33.33,
            acceptedRotation: 0
            }
          ]  
        },
        curve90 : {
          width: 112.96,
          height: 112.96,
          connections: [
            {
            x: 0,
            y: 33.33,
            acceptedRotation: 0
            },{
            x: 79.63,
            y: 112.96,
            acceptedRotation: 90
           }
           ]
        },
        curve45 : {
          width: 82,
          height: 79,
          connections: [
            {
            x: 0,
            y: 33.33,
            acceptedRotation: 0
            },{
            x: 58,
            y: 55,
            acceptedRotation: 45
           }
           ]
        } 
      };

      // list of parts avaible
      var parts = Array();

      // the currently selected part
      var currentSelectedPart = null;

      // rotates the current selected part
      var rotatePart = function(rotateRight) {
        if(currentSelectedPart == null) {
          return;
        } 

        var currentRotation = calcRotation(rotateRight,currentSelectedPart.getRotation());
        currentSelectedPart.setRotation(currentRotation);

        for(i=0; i < currentSelectedPart.detectionCirles.length; i++) {
          currentSelectedPart.detectionCirles[i].acceptedRotation = calcRotation(rotateRight,currentSelectedPart.detectionCirles[i].acceptedRotation);
          colorCirclesForDebug(currentSelectedPart.detectionCirles[i]);
        }

        layer.draw();
      }

      var deletePart = function() {
      	if(currentSelectedPart == null) {
          return;
        }

        unboundPart(currentSelectedPart);

        currentSelectedPart.destroyChildren();
        currentSelectedPart.destroy();

        for(i=0; i < parts.length; i++) {
          if(parts[i].id == currentSelectedPart.id) {
          	parts.splice(i, 1);
          	break;
          }
        }

        currentSelectedPart = null;

        layer.draw();
      }

      var exportData = function() {
      	var json = stage.toJSON();
        console.log(json);
      }

      var colorCirclesForDebug = function(circle) {
      	var color = "";
      	switch(circle.acceptedRotation) {
      		case 0:
      		  color = 'red';
      		  break;
      		case 45:
      		  color = 'orange';
      		  break;
      		case 90:
      		  color = 'green';
      		  break;
      		case 135:
      		  color = 'yellow';
      		  break;  
      		case 180:
      		  color = 'red';
      		  break;
      		case 225:
      		  color = 'orange';
      		  break;
      		case 270:
      		  color = 'green';
      		  break;
      		case 315:
      		  color = 'yellow';
      		  break;    
      	}
      	circle.fill(color);
      }

      
      var calcRotation = function(rotateRight,currentRotation) {
        if(rotateRight == true) {
          currentRotation+=45; 
          if(currentRotation == 360) {
            currentRotation = 0;
          }
        } else {
          if(currentRotation == 0) {
            currentRotation = 360;
          }
          currentRotation-=45;
        }

        return currentRotation;
      }

      var highlightPart = function(partGroup) {
      	if(currentSelectedPart != null) {
      		currentSelectedPart.find('.highlight').hide();
      	}
   
        // deselect the current part
        if(currentSelectedPart != null && currentSelectedPart.getId() == partGroup.getId()) {
          currentSelectedPart = null;
        } else {
          currentSelectedPart = partGroup;
          currentSelectedPart.find('.highlight').show();
        }
        layer.draw();
      }

      var unboundPart = function(part) {
          // check if any part is bounded to this part and remove the bounding from it
          for(i=0; i < part.detectionCirles.length; i++) {
          	  if(part.detectionCirles[i].boundTo != null) {
          	  	part.detectionCirles[i].boundTo.boundTo = null;
          	  	part.detectionCirles[i].boundTo = null;
          	  }
          }	
      }

      // function for adding a new part to the tracke
      var addPart = function(name) {

        if(partTypes[name] == null) {
          return;
        }

        var partType = partTypes[name];
        
        var group = new Kinetic.Group({
          x: 0,
          y: 0,
          rotation: 0,
          draggable: true,
          id: 'part_'+partIdSeq++,
          name: 'trackPart',
          trackPartType: partType
        });
        group.detectionCirles = new Array();
        

      var imageObj = new Image();
      imageObj.onload = function() {
        var kImage = new Kinetic.Image({
          x: 0,
          y: 0,
          image: imageObj,
          width: partType.width,
          height: partType.height
        });

        // add the shape to the layer
        group.add(kImage);
        
        // create the higlight shape
        var highlightrect = new Kinetic.Rect({
          x: 0,
          y: 0,
          width: partType.width,
          height: partType.height,
          fill: 'green',
          stroke: 'black',
          strokeWidth: 1,
          name: 'highlight',
          opacity: 0.5                    
        });
        group.add(highlightrect);
        highlightPart(group);
        layer.draw();
      };
      imageObj.src = name+'.png';
        
        // add the connection points
        for(i=0; i< partType.connections.length; i++) {
          var circle = new Kinetic.Circle({
            x: partType.connections[i].x,
            y: partType.connections[i].y,
            radius: 10,
            fill: 'red',
            stroke: 'black',
            strokeWidth: 1
          });
          circle.acceptedRotation = partType.connections[i].acceptedRotation; 
          group.add(circle);
          group.detectionCirles.push(circle);
        }

        layer.add(group);
        parts.push(group);

        group.setX(((stage.getWidth() / 2)-stage.getAbsolutePosition().x) / stage.getScale().y);
        group.setY(((stage.getHeight() / 2)-stage.getAbsolutePosition().y) / stage.getScale().y);  
        layer.draw();

        group.on('dragstart', function() {
        	if(currentSelectedPart != null && currentSelectedPart.getId() != this.getId()) {
        	  highlightPart(this);
        	}
        });	

        group.on('dragstart', function() {
        	unboundPart(this);
        });	

        group.on('dragend', function() {
          if(parts.length == 1) {
            return;
          } 
          for(h=0; h < parts.length; h++) {
            var part = parts[h];
            if(part.getId() != this.getId()) {
              for(j=0; j < part.detectionCirles.length; j++) {
                
                // check if the part circle is already bound 
                if(part.detectionCirles[j].boundTo != null) {
                  continue;
                }

                var partPos = part.detectionCirles[j].getAbsolutePosition();
                
                // check if the draged part circles are in the sticky attach range
                for(i=0; i < this.detectionCirles.length; i++) {
                  var circlPos = this.detectionCirles[i].getAbsolutePosition();

                  var distanceX = circlPos.x - partPos.x;
                  var distanceY = circlPos.y - partPos.y;
                  var distance = Math.sqrt((distanceX * distanceX) + (distanceY * distanceY));
                  // lets attach the part to the other one
                  if(distance <= 15 *  stage.getScale().y) {
                    this.offsetX(this.detectionCirles[i].getX());
                    this.offsetY(this.detectionCirles[i].getY());

                    // check if to rotate the part 
                    /*var circleRotation = part.detectionCirles[j].acceptedRotation;
                    var circleRotation2 = (circleRotation2 <= 180) ? circleRotation + 180 :  circleRotation - 180;
                    if(this.getRotation() != circleRotation  && this.getRotation() != circleRotation2) {
                      this.setRotation(circleRotation);                      	
                    } */                
                    

                    this.setX((partPos.x / stage.getScale().y)-(stage.getAbsolutePosition().x / stage.getScale().y));
                    this.setY((partPos.y / stage.getScale().y)-(stage.getAbsolutePosition().y / stage.getScale().y));

                    // mark the track part ends bounded 
                    part.detectionCirles[j].boundTo = this.detectionCirles[i];
                    this.detectionCirles[i].boundTo = part.detectionCirles[j];
                  }
                }
              }
            }
          }
          layer.draw();
        });

       group.on('click',function() {
         highlightPart(this);
       });
      }

      var stage = new Kinetic.Stage({
        container: 'container',
        width:  window.innerWidth,
        height: window.innerHeight-100,
        draggable: true
      });

      var layer = new Kinetic.Layer();
          
      // add the layer to the stage
      stage.add(layer);

      


      var zoom = function(e) {
      	e.preventDefault();
        var zoomAmount = e.wheelDeltaY*0.001;
        var scale = stage.getScale().y+zoomAmount;
        stage.setScale({x: scale, y: scale});
        layer.draw();
      }
      document.addEventListener("mousewheel", zoom, false)
    </script>
  </body>
</html>